philosophers

철학자 식사 문제
	https://ko.wikipedia.org/wiki/식사하는_철학자들_문제
	
	각 프로그램은 같은 옵션을 가져야 합니다 : 
		철학자의 수 (number_of_philosophers): 
			테이블에 앉아 있는 철학자의 수와 포크의 수

		철학자의 수명 (time_to_die): 
			밀리초 단위로, 철학자가 마지막으로 밥을 먹은 지 'time_to_die' 시간만큼이 지나거나, 
			프로그램 시작 후 'time_to_die' 시간만큼이 지나면 해당 철학자는 사망합니다.

		밥을 먹는데 걸리는 시간 (time_to_eat) : 
			밀리초 단위로, 철학자가 밥을 먹는 데 걸리는 시간입니다. 
			해당 시간동안, 철학자는 두 개의 포크를 소유하고 있어야 합니다.

		잠자는 시간 (time_to_sleep) : 
			밀리초 단위로, 잠을 자는 데 소모되는 시간입니다.

		각 철학자가 최소한 밥을 먹어야 하는 횟수 (number_of_times_each_philosopher_must_eat) : 
			해당 인자값은 선택사항입니다. 모든 철학자가 'number_of_times_each_philosopher_must_eat' 횟수만큼 밥을 먹었다면, 
			시뮬레이션이 종료됩니다. 해당 값이 명시되어 있지 않다면, 철학자가 한 명이라도 사망할 때까지 시뮬레이션은 계속됩니다.

컨텍스트 스위칭(context swiching)
	https://applefarm.tistory.com/105

	멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 
	다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 
	저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 
	교체하는 작업을 Context Switch(Context Switching)라고 한다.

	컨텍스트 스위칭은 다음과 같은 상황에서 일어난다.
	1. I/O interrupt
	2. CPU 사용시간 만료
	3. 자식 프로세스 Fork
	4. 인터럽트 처리를 기다릴 때

	컨텍스트 스위칭시에는
	해당 스레드만을 위한 스택 영역이 생성되고, 나머지 영역 Code, Data, Heap은 
	부모 프로세스 영역에서 공유하고 있다. 스레드 마다 스택을 독립적으로 할당해준다.
	프로세스는 레지스터 수, 프로세스에서 관리되어야 할 데이터 종류가 많을 수록 부담이 된다. 
	컨텍스트 스위칭에 소요되는 시간을 줄이려면 저장하고 복원되는 컨텍스트 정보를 줄여야 한다.

교착상태 4가지 필요 조건
	1. 상호배타(Mutual Exclusion)
	예) 젓가락은 한번에 한 철학자만 사용할 수 있다.

	2. 보유 및 대기(Hold and Wait)
	예) 집어든 젓가락은 계속 들은 채로 사용중인 반대쪽 젓가락을 기다린다.

	3. 비선점(No Preemption)
	예) 이미 누군가 집어든 젓가락을 강제로 뺏을 수 없다.

	4. 환형대기(Circular Wait)
	예) 모든 철학자들이 자신의 오른쪽에 앉은 철학자가 젓가락을 놓기를 기다린다.

스레드
	https://velog.io/@ckstn0777/OS-%EC%8A%A4%EB%A0%88%EB%93%9C

	스레드는 CPU 이용의 기본 단위. 프로세스 내에서 실행되는 여러 흐름의 단위
	각 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성되어있음
	같은 프로세스에 속하는 스레드는 서로 코드, 데이터섹션, Heap, 열린파일이나 신호와 같은 운영체제 자원들을 공유

	멀티스레드 장단점
		장점
		시스템 자원 소모 감소(자원의 효율성 증대) : 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리
		시스템 처리량 증가(처리 비용 감소) : 스레드 사이의 작업량이 작아 Context Switching이 빠르다.
		간단한 통신 방법으로 인한 프로그램 응답 시간 단축 : 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.
		곰곰히 생각해보면 결국 프로세스와는 다르게 스레드는 자원을 공유하기 때문에 여러 부가적인 장점들이 생기게 된다는 것을 알 수 있습니다.

		단점
		스레드 하나가 프로세스 내 자원을 망쳐버린다면 모든 프로세스가 종료될 수 있다.
		자원을 공유하기 때문에 필연적으로 동기화 문제가 발생할 수밖에 없다.

	스레드와 프로세스의 차이점
		프로세스는 완벽히 독립적이기 때문에 메모리 영역을 다른 프로세스와 공유를 하지 않지만
		스레드는 해당 스레드를 위한 스택을 생성할 뿐 프로세스 내의 메모리를 공유해서 사용할 수 있다.

자원 동기화 문제
	https://woovictory.github.io/2018/12/26/OS-MultiThread-Concept/#:~:text=%EB%8F%99%EA%B8%B0%ED%99%94%EB%9E%80%3F,%EB%A5%BC%20%EC%A1%B0%EC%A0%95%ED%95%B4%EC%A3%BC%EB%8A%94%20%EA%B8%B0%EB%B2%95%EC%9D%B4%EB%8B%A4.

	임계영역(Critical Section)
	둘 이상의 쓰레드(또는 프로세스)가 공유 자원에 동시에 접근하면 문제가 발생할 수 있다. 
	이런 문제를 일으킬 수 있는 코드 블록을 임계 영역이라고 한다. 다시 말해 임계 영역은 
	배타적 접근 권한(한 순간에 하나의 쓰레드만 접근)이 요구되는 공유 리소스(전역변수, static 변수 등)에 접근하는 코드 블럭을 의미한다.

	상호배제
	상호 배제는 한 프로세스가 공유 자원을 접근하는 임계 영역 코드를 수행하고 있으면 다른 프로세스는 
	공유 자원을 접근하는 임계 영역의 코드를 수행할 수 없다는 조건이다.

	임계 영역을 보호하기 위한 개념
		둘 이상의 프로세스(혹은 쓰레드)가 공유자원에 대해 동시에 읽거나 쓰는 것을 방지하기 위한 기법
		상호 배제 기법에는 뮤텍스, 세마포어, 모니터, 메시지 전달 등의 기법이 있다.


사용가능함수
int usleep (useconds_t microseconds);
	일정시간 동안 대기하는 함수

	헤더 : unistd.h
	인자 : microseconds - 대기할 시간(ms)
	반환 : 성공 0, 실패 -1

int gettimeofday(struct timeval *restrict tp, void *restrict tzp);
	현재시간을 반환하는 함수

	헤더 : #include <sys/time.h>
	인자 : 
		struct timeval {
            time_t       tv_sec;   /* seconds since Jan. 1, 1970 */
            suseconds_t  tv_usec;  /* and microseconds */
    	};

    	struct timezone {
             int     tz_minuteswest; /* of Greenwich */
             int     tz_dsttime;     /* type of dst correction to apply */
    	};
		현재 timezone 구조체는 사용되지 않고 있으며, 앞으로도 지원되지 않을 것이다. 간혹 커널 소스등에서 이 필드가 사용되는 경우가 있는데, 
		모든 경우에 버그로 판단되어서 무시한다. 복잡하게 생각할 필요 없이 tz은 NULL을 사용하도록 한다.
	반환 : 성공 0, 실패 -1

int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
	스레드 생성 함수

	헤더 : pthread.h
	인자 : thread - 쓰레드가 성공적으로 생성되었을때 생성된 쓰레드를 식별하기 위해서 사용되는 쓰레드 식별자
		  attr   - 쓰레드 특성을 지정하기 위해서 사용하며, 기본 쓰레드 특성을 이용하고자 할경우에 NULL 을 사용
		  start_routine - 분기시켜서 실행할 쓰레드 함수
		  arg -  start_routine 쓰레드 함수의 매개변수
	반환 : 성공 0, 실패 errno

int pthread_detach(pthread_t thread);
	특정 쓰레드를 분리시키는 함수
	일반적으로 쓰레드를 pthread_create() 를 사용하여 생성하면, 쓰레드가 종료되더라도 사용했던 모든 자원이 해제되지 않음 
	반면 pthread_join() 을 사용하여 종료될때까지 기다렸다가 종료시점이 되면, 자원이 반납됨 
	pthread_detach() 함수는 pthread_join()을 사용하지 않더라도,  쓰레드 종료될때 모든 자원을 해제됨

	헤더 : pthread.h
	인자 : thread - 분리시킬 쓰레드 식별자
	반환 : 성공 0, 실패 errno

int pthread_join(pthread_t thread, void **value_ptr);
	특정 쓰레드가 종료하기를 기다렸다가, 쓰레그가 종료된 이후 다음 진행
	join된 쓰레드 (종료된 쓰레드)는 모든 자원을 반납
	
	헤더 : pthread.h
	인자 : thread - 기다릴 쓰레드 식별자
		  ptr    - 쓰레드의 리턴값
	반환 : 성공 0, 실패 errno

int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
	뮤택스 객체를 초기화 하는 함수

	헤더 : pthread.h
	인자 : mutex - 초기화 시킬 뮤텍스 객체
		  attr  - mutex 특성을 변경할수 있다. 기본 mutex 특성을 이용하기 원한다면 NULL을 사용
	반환 : 성공 0, 실패 errno

int pthread_mutex_destroy(pthread_mutex_t *mutex);
	뮤텍스 객체를 삭제하고 자원을 되돌려줌

	헤더 : pthread.h
	인자 : mutex - 삭제시킬 뮤텍스 객체
	반환 : 성공 0, 실패 errno

int pthread_mutex_lock(pthread_mutex_t *mutex);
	뮤텍스 잠금을 해주는 함수

	헤더 : pthread.h
	인자 : mutex - 잠금할 뮤텍스 객체
	반환 : 성공 0, 실패 errno

int pthread_mutex_unlock(pthread_mutex_t *mutex);
	뮤텍스 잠금을 되돌려주는 함수

	헤더 : pthread.h
	인자 : mutex - 잠금을 풀어줄 뮤텍스 객체
	반환 : 성공 0, 실패 errno