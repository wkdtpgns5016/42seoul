get_next_line

get_next_line 함수 설명
    https://epicarts.tistory.com/154

gcc -Wall -Wextra -Werror -D BUFFER_SIZE=42 <파일들>.c
    1. -D[매크로]=[매크로 값] 옵션 : 소스 내에 #define [매크로] [매크로 값] 옵션을 추가

파일디스크립터(fd)
    1. 개념 : 파일 디스크립터(File Descriptor)란 리눅스 혹은 유닉스 계열의 시스템에서 프로세스(process)가 
    파일(file)을 다룰 때 사용하는 개념으로, 프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값이다. 
    파일 디스크럽터는 일반적으로 0이 아닌 정수값을 갖는다. 
    흔히 유닉스 시스템에서 모든 것을 파일이라고 한다. 일반적인 정규파일부터 디렉토리, 소켓, 파이프, 블록 디바이스, 
    케릭터 디바이스 등 모든 객체들을 파일로 관리한다. 유닉스 시스템에서 프로세스가 이 파일들을 접근할 때 
    파일 디스크립터라는 개념일 이용한다. 프로세스가 실행 중에 파일을 Open하면 커널은 해당 프로세스의 파일 디스크립터 
    숫자 중 사용하지 않는 가장 작은 값을 할당해준다. 그 다음 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 
    파일 디스크립터(FD)값을 이용해서 파일을 지칭할 수 있다.
    프로그램이 프로세스로 메모리에서 실행될 때, 기본적으로 할당되는 파일디스크립터는 표준입력(Standard Input), 
    표준 출력(Standard Output), 표준에러(Standard Error)이며 이들에게 각각 0, 1, 2라는 정수가 할당된다.

    2. 요약 : 유닉스 시스템에서는 객체들을 모두 파일이라고 하는데, 파일에 접근할 때, 이 fd값을 이용하여 파일을 지칭함
    파일에 접근하면 커널은 fd값중 사용하지 않는 가장 작은 값을 할당함. 기본적으로 할당되는 fd값은 0 1 2 인데
    각각 표준입력, 표준출력, 표준에러임

    1) 표준 입력 [0 - stdin]
        키보드로 명령어를 치고 엔터를 이용해 입력하는 방식을 의미합니다. 파일 디스크립터에서 0번으로 지정됩니다.
    2) 표준 출력 [1 - stdout]
        키보드로 명령어를 실행하고 정상 종료 시 출력되는 내용을 의미합니다. 파일 디스크립터에서 1번으로 지정됩니다.
    3) 표준 에러 [2 - stderr]
        명령어 실행 시 발생한 에러 메시지 내용을 의미합니다. 파일 디스크립터에서 2번으로 지정됩니다.

open 함수
    헤더: fcntl.h
    형태: int open(const char *path, int flags);
         int open(const char *path, int flags, mode_t mode);
    반환값: 파일디스크립터, 오류시 (-1)

read 함수
    헤더: unistd.h
    형태: ssize_t read (int fd, void *buf, size_t nbytes)
    인수: int fd 파일 디스크립터
    void *buf 파일을 읽어 들일 버퍼
    size_t nbytes 퍼버의 크기
    반환값: -1(실패), 양수(읽은 바이트 수)

lseek
    함수의 seek pointer (커서) 를 조정하는 함수입니다. 조정된 seek pointer 는 파일의 read/write 시 사용됩니다.
    특정 위치부터 읽거나 쓰고싶을때 유용합니다.

정적 변수
    자료형 앞에 static 키워드를 붙임
    초기화를 하지 않아도 자동으로 0이 저장됨
    반복문의 중괄호 내에서 선언 되었더라도 초기화는 한번만 수행
    정적 지역 변수의 메모리 생성 시점 중괄호 내에서 초기화 될때
    정적 지역 변수의 메모리 소멸 시점 프로그램이 종료될때

gnl 초기구현 로직
    만약에 버퍼에 저장한 문자열에서 개행이 없을경우
    1. (백업이 null이면) 그냥 백업에 저장
    2. (백업에 값 있으면) 기존꺼랑 더해서 저장

    만약에 버퍼에 저장한 문자열에서 개행이 있을경우
    1. (백업이 null이면) 개행 전까지의 문자열 반환하고, 개행 후의 문자열 백업에 저장
    2. (백업에 값 있으면) 기존꺼랑 개행 전까지 더해서 반환, 개행 후의 문자열 백업에 저장

    초기 구상 로직의 문제점 : read시, 버퍼안에 개행이 여러개 있을때,
        다음 반환 문자열에서 개행이 포함되어 반환되어짐
    해결방안 : read 전에 버퍼안에 개행이 있는지 검사하고 개행이 있다면 개행 앞까지의 문자열을 반환함

    백업에 대한 로직 수정 필요
        백업에 그냥 read한 내용 자체를 저장시키고, 나중에 값을 핸들링하는것이 더 처리하기 쉬워보임.
        처음에 read한 내용 전체를 이전것과 합치고, 이후, line을 만드는 함수를 처리하고, 그 후, line에 해당하는 내용을 짤라서 처리

힙과 스택
    일반적으로 변수를 선언하게 되면 스택에 메모리가 할당되며,
    malloc으로 메모리를 동적으로 할당하게 된다면 힙에 메모리가 할당된다.

Stack Segment(= Call Segment)
    스택 자료구조로 구현되어 있다. (함수가 호출되고 종료될 때 호출됐던 곳으로 돌아가는 방식)
    크기 : 메모리 영역의 크기가 고정되어 있다. 크기가 비교적 작다. (windows에서는 1MB)
    속도 : 할당이 비교적 빠르다. 변수를 통해 직접 접근할 수 있다.

Heap Segment
    동적메모리할당. 주소가 순차적으로 할당되지는 않는다. 메모리의 주소는 포인터에 저장해서 사용한다.
    크기 : 큰 메모리 풀이다. (일반적으로 2GB)
    속도 : 할당이 비교적 느리다. 포인터를 통해 접근하므로, 역참조해야 해서 좀더 느리다.

보너스 로직 구상
    기존 백업를 2차원으로 구현하여 각 파일 디스크럽터에 해당하는 내용을 백업에 저장할 수 있도록 해야함.
    https://velog.io/@yeunjoo121/getnextline%EA%B5%AC%ED%98%84 참고 블로그

디버깅 lldb
    lldb를 쓰기 위해서 먼저 gcc 컴파일을 할 때 -g 플래그를 넣어 컴파일하고 a.dSYM 파일이 생기도록 한다
    컴파일 후에 lldb (실행파일) < 명령어를 하면 lldb 쉘모드가 된다

    breakpoint : 프로그램 실행에서 실행 도중 정지 시점을 지정할 수 있다. b (코드 라인) < 명령어로 코드 라인 전까지 실행하고 정지 시킬 수 있다.
                br del (break point 번호) <로 해당 정지 지점을 삭제 할 수 있다.

    next, step : breakpoint로 정지 시키고, next와 step으로 한 라인씩 실행할 수 있다. 
        next (step over) = 한 줄을 실행하되, 함수가 있다면 함수 안으로 들어가지 않는다.
        step (step into) = 한 줄을 실행하되, 함수가 있다면 함수 안으로 들어가진다.

    continue : breakpoint와 breakpoint 사이의 코드를 한번에 실행하고자 할 경우 활용한다.
    finish : 함수를 빠져나올때 사용하는 명령어이다.

    print : 프로그램 실행 도중 해당 변수의 값을 알고 싶을 때 해당 명령어를 이용
        ex) p *ptr <- 포인터 변수 ptr가 가르키는 주소의 값을 출력
    https://hyeyoo.com/64
    
메모리 누수 검사
    1. leaks 명령어 : lldb와 함께 쓰면 좋다, lldb로 breakpoint를 지정하여 프로그램을 정지 시킨후 해당 프로세스의 PID를 이용하여 메모리누수 확인
    2. gcc -fsanitize=address 플래그 : 컴파일 할때 해당 플래그를 사용하여 컴파일하고 실행파일을 실행시, 메모리누수 여부를 알려준다.
    https://love-every-moment.tistory.com/48
    
메모리구조
    http://www.tcpschool.com/c/c_memory_structure
    
    1. 코드 영역 : 우리가 작성한 소스코드가 들어 가는 부분. 즉, 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code)영역이라고도 부른다.
    코드영역은 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 함수, 제어문, 상수 등이 여기에 지정된다.
    
    2. 데이터 영역 : 전역변수와 static변수가 할당되는 영역
    프로그램의 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리가 소멸되는 영역
    데이터 영역에서 초기화 없이 변수가 선언이 되면 자동으로 0 값을 초기화 시켜준다.
    
    3. 스택 영역 : 프로그램이 자동으로 사용하는 임시 메모리 영역이다.
    함수 호출 시 생성되는 지역 변수와 매개변수가 저장되는 영역이고, 함수 호출이 완료되면 사라진다.
    
    4. 힙 영역 : 프로그래머가 할당/해제하는 메모리 공간이다. Java에서는 가비지 컬렉터가 자동으로 해제합니다.
    이 공간에 메모리 할당하는 것을 동적 할당(Dynamic Memory Allocation)이라고도 부른다.
    
    위의 HEAP과 STACK영역은 사실 같은 공간을 공유한다. HEAP이 메모리 위쪽 주소부터 할당되면 STACK은 아래쪽부터 할당되는 식이다. 
    그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 HEAP OVERFLOW, STACK OVERFLOW라고 칭합니다.

    Stack 영역이 크면 클 수록 Heap 영역이 작아지고, Heap 영역이 크면 클수록 Stack 영역이 작아집니다.
    
ulimit 명령어
    Ulimit [조회 옵션] 값
    -a : 모든 제한 사항을 보여줌.
    -c : 최대 코어 파일 사이즈
    -d : 프로세스 데이터 세그먼트의 최대 크기
    -f : shell에 의해 만들어질 수 있는 파일의 최대 크기
    -s : 최대 스택 크기
    -p : 파이프 크기
    -n : 오픈 파일의 최대수
    -u : 오픈파일의 최대수
    -v : 최대 가상메모리의 양
    -S : soft 한도
    -H : hard 한도

open_max
    limit.h
    클러스터 아이맥의 터미널 ulimit -n 시 oepn max file의 수는 256으로 설정되어 있다.
    vscode 개발 환경 상에서는 ulimit -n 시 open max file의 수는 12800으로 설정되어 있다.
    개발환경에 따라 open_max 값이 달라진다.
